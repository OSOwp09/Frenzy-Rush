Unity Editor version:    2021.3.21f1 (1b156197d683)
Branch:                  2021.3/staging
Build type:              Release
Batch mode:              YES
macOS version:           Version 10.13.6 (Build 17G13035)
Darwin version:          17.7.0
Architecture:            x86_64
Running under Rosetta:   NO
Available memory:        8192 MB
Using pre-set license
Pro License: YES

COMMAND LINE ARGUMENTS:
/Applications/Unity/Unity.app/Contents/MacOS/Unity
-adb2
-batchMode
-noUpm
-name
AssetImportWorker0
-projectPath
/Users/oso/Desktop/semestre/videojuegos/juego/Frenzy-Rush/FrenzyRush
-logFile
Logs/AssetImportWorker0.log
-srvPort
49618
Successfully changed project path to: /Users/oso/Desktop/semestre/videojuegos/juego/Frenzy-Rush/FrenzyRush
/Users/oso/Desktop/semestre/videojuegos/juego/Frenzy-Rush/FrenzyRush
[UnityMemory] Configuration Parameters - Can be set up in boot.config
    "memorysetup-bucket-allocator-granularity=16"
    "memorysetup-bucket-allocator-bucket-count=8"
    "memorysetup-bucket-allocator-block-size=33554432"
    "memorysetup-bucket-allocator-block-count=8"
    "memorysetup-main-allocator-block-size=16777216"
    "memorysetup-thread-allocator-block-size=16777216"
    "memorysetup-gfx-main-allocator-block-size=16777216"
    "memorysetup-gfx-thread-allocator-block-size=16777216"
    "memorysetup-cache-allocator-block-size=4194304"
    "memorysetup-typetree-allocator-block-size=2097152"
    "memorysetup-profiler-bucket-allocator-granularity=16"
    "memorysetup-profiler-bucket-allocator-bucket-count=8"
    "memorysetup-profiler-bucket-allocator-block-size=33554432"
    "memorysetup-profiler-bucket-allocator-block-count=8"
    "memorysetup-profiler-allocator-block-size=16777216"
    "memorysetup-profiler-editor-allocator-block-size=1048576"
    "memorysetup-temp-allocator-size-main=16777216"
    "memorysetup-job-temp-allocator-block-size=2097152"
    "memorysetup-job-temp-allocator-block-size-background=1048576"
    "memorysetup-job-temp-allocator-reduction-small-platforms=262144"
    "memorysetup-temp-allocator-size-background-worker=32768"
    "memorysetup-temp-allocator-size-job-worker=262144"
    "memorysetup-temp-allocator-size-preload-manager=33554432"
    "memorysetup-temp-allocator-size-nav-mesh-worker=65536"
    "memorysetup-temp-allocator-size-audio-worker=65536"
    "memorysetup-temp-allocator-size-cloud-worker=32768"
    "memorysetup-temp-allocator-size-gi-baking-worker=262144"
    "memorysetup-temp-allocator-size-gfx=262144"
Player connection [140735838241664] Host "[IP] 11.11.2.131 [Port] 0 [Flags] 2 [Guid] 1224980003 [EditorId] 1224980003 [Version] 1048832 [Id] OSXEditor(0,MacBook-Pro-de-Oso.local) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined multi-casting on [225.0.0.222:54997]...

Player connection [140735838241664] Host "[IP] 11.11.2.131 [Port] 0 [Flags] 2 [Guid] 1224980003 [EditorId] 1224980003 [Version] 1048832 [Id] OSXEditor(0,MacBook-Pro-de-Oso.local) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined alternative multi-casting on [225.0.0.222:34997]...

Refreshing native plugins compatible for Editor in 727.70 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Initialize engine version: 2021.3.21f1 (1b156197d683)
[Subsystems] Discovering subsystems at path /Applications/Unity/Unity.app/Contents/Resources/UnitySubsystems
[Subsystems] Discovering subsystems at path /Users/oso/Desktop/semestre/videojuegos/juego/Frenzy-Rush/FrenzyRush/Assets
GfxDevice: creating device client; threaded=0; jobified=0
Color LCD preferred device: Intel(R) Iris(TM) Graphics 6100 (low power)
Metal devices available: 1
0: Intel(R) Iris(TM) Graphics 6100 (low power)
Using device Intel(R) Iris(TM) Graphics 6100 (low power)
Initializing Metal device caps: Intel(R) Iris(TM) Graphics 6100
Initialize mono
Mono path[0] = '/Applications/Unity/Unity.app/Contents/Managed'
Mono path[1] = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/lib/mono/unityjit-macos'
Mono config path = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56523
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: /Applications/Unity/Unity.app/Contents/PlaybackEngines/MacStandaloneSupport/UnityEditor.OSXStandalone.Extensions.dll
Registered in 0.001955 seconds.
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 231.19 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.166 seconds
Domain Reload Profiling:
	ReloadAssembly (2167ms)
		BeginReloadAssembly (232ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (0ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (2ms)
		EndReloadAssembly (1557ms)
			LoadAssemblies (231ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (469ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (116ms)
			SetupLoadedEditorAssemblies (770ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (16ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (231ms)
				BeforeProcessingInitializeOnLoad (2ms)
				ProcessInitializeOnLoadAttributes (431ms)
				ProcessInitializeOnLoadMethodAttributes (89ms)
				AfterProcessingInitializeOnLoad (0ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (0ms)
Platform modules already initialized, skipping
Registering precompiled user dll's ...
Registered in 0.006365 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/oso/Desktop/semestre/videojuegos/juego/Frenzy-Rush/FrenzyRush/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/oso/Desktop/semestre/videojuegos/juego/Frenzy-Rush/FrenzyRush/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.01 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
Package Manager log level set to [2]
- Completed reload, in  2.547 seconds
Domain Reload Profiling:
	ReloadAssembly (2550ms)
		BeginReloadAssembly (307ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (18ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (66ms)
		EndReloadAssembly (1952ms)
			LoadAssemblies (213ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (668ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (177ms)
			SetupLoadedEditorAssemblies (797ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (155ms)
				ProcessInitializeOnLoadAttributes (568ms)
				ProcessInitializeOnLoadMethodAttributes (55ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (10ms)
Platform modules already initialized, skipping
========================================================================
Worker process is ready to serve import requests
Launching external process: /Applications/Unity/Unity.app/Contents/Tools/UnityShaderCompiler
Launched and connected shader compiler UnityShaderCompiler after 0.04 seconds
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1 = log2(float4(VGlobals._SkyTint.x, VGlobals._SkyTint.y, VGlobals._SkyTint.z, VGlobals._AtmosphereThickness));
    u_xlat1 = u_xlat1 * float4(0.454545468, 0.454545468, 0.454545468, 2.5);
    u_xlat1 = exp2(u_xlat1);
    u_xlat1.xyz = (-u_xlat1.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat2.xy = u_xlat1.ww * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat0.y), u_xlat21, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = fma(VGlobals._GroundColor.xxyz.yzw, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Refreshing native plugins compatible for Editor in 1.05 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3163 Unused Serialized files (Serialized files now loaded: 0)
Unloading 37 unused Assets / (65.8 KB). Loaded Objects now: 3610.
Memory consumption went from 104.8 MB to 104.7 MB.
Total: 9.448284 ms (FindLiveObjects: 0.448165 ms CreateObjectMapping: 0.502863 ms MarkObjects: 8.296344 ms  DeleteObjects: 0.199151 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 20863.054058 seconds.
  path: Assets/Readme.asset
  artifactKey: Guid(7f2c382dc2c22446db59030979f6e495) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Readme.asset using Guid(7f2c382dc2c22446db59030979f6e495) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '9990f39c3de691f85cda2915bc54e9c4') in 0.146291 seconds 
